import React, { useState } from 'react';
import { TextField, Typography, Button, Card, CardContent } from '@mui/material';
import styled from 'styled-components';
import sha256 from 'crypto-js/sha256';
import { shake256 } from 'js-sha3';

const StyledContainer = styled.div`
  max-width: 960px;
  margin: 40px auto;
  padding: 30px;
  background: #fff;
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  border-radius: 8px;
  font-family: 'Roboto', sans-serif;
`;

const StyledControls = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
  gap: 20px;
  margin: 20px 0;
`;

const InfoDisplay = ({ title, data, children }) => (
  <Card variant="outlined" style={{ margin: '20px 0' }}>
    <CardContent>
      <Typography color="textSecondary" gutterBottom>
        {title}
      </Typography>
      {data && <Typography variant="body2">{data}</Typography>}
      {children}
    </CardContent>
  </Card>
);

const DilithiumVerification = () => {
  const [message, setMessage] = useState('');
  const [digest, setDigest] = useState('');
  const [signature, setSignature] = useState([]);
  const [isValidSignature, setIsValidSignature] = useState(false);
  const [publicKey, setPublicKey] = useState([]);

  const generatePublicKey = () => {
    const secretKey = Array.from({ length: 256 }, () => Math.floor(Math.random() * 8380417));
    const publicKey = secretKey.map(k => (k * k) % 8380417);
    setPublicKey(publicKey);
    return secretKey;
  };

  const handleSignMessage = () => {
    const secretKey = generatePublicKey();
    const messageDigest = sha256(message).toString();
    setDigest(messageDigest);

    const signature = secretKey.map(sk => (sk + parseInt(messageDigest.substring(0, 8), 16)) % 8380417);
    setSignature(signature);

    verifySignature(secretKey, signature, messageDigest);
  };

  const verifySignature = (secretKey, signature, digest) => {
    const expectedSignature = secretKey.map(sk => (sk + parseInt(digest.substring(0, 8), 16)) % 8380417);
    const isValid = expectedSignature.every((s, index) => s === signature[index]);
    setIsValidSignature(isValid);
  };

  return (
    <StyledContainer>
      <Typography variant="h4" gutterBottom>Dilithium Signing and Verification Process</Typography>
      <Typography variant="body1" style={{ marginBottom: '20px' }}>
        The Dilithium cryptographic algorithm uses lattice-based problems, specifically designed to be secure against quantum computing threats. The security of the algorithm relies on the difficulty of finding short vectors in high-dimensional lattices, which is computationally hard.
      </Typography>
      <StyledControls>
        <TextField
          label="Enter Message"
          fullWidth
          value={message}
          onChange={e => setMessage(e.target.value)}
        />
        <Button variant="contained" color="primary" onClick={handleSignMessage}>
          Sign and Verify Message
        </Button>
      </StyledControls>

      <InfoDisplay title="Message Digest (SHA-256)" data={digest}>
        <Typography variant="body2">
          SHA-256 is utilized to create a fixed-size digest of the message. This process reduces the data complexity and ensures that the integrity of the data can be securely signed.
        </Typography>
      </InfoDisplay>
      <InfoDisplay title="Public Key" data={publicKey.join(', ')}>
        <Typography variant="body2">
          Each element of the public key is generated by squaring elements of the secret key and taking the result modulo a large prime number, q. This quadratic residue problem underpins the security of public key schemes in lattice-based cryptography.
        </Typography>
      </InfoDisplay>
      <InfoDisplay title="Signature" data={signature.join(', ')}>
        <Typography variant="body2">
          The signature is created by adding a value derived from the message digest to the secret key modulo q. This ensures that the signature is tied cryptographically to both the message and the secret key.
        </Typography>
      </InfoDisplay>
      <InfoDisplay title="Verification Result" data={isValidSignature ? "Valid" : "Invalid"}>
        <Typography variant="body2">
          During verification, the signature is recalculated using the stored public key and compared to the original signature. A match confirms the message's authenticity and the signer's identity.
        </Typography>
      </InfoDisplay>
    </StyledContainer>
  );
};

export default DilithiumVerification;
