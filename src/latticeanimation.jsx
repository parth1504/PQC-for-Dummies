import React, { useState, useEffect } from 'react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls } from '@react-three/drei';
import * as THREE from 'three';

const LatticePoint = ({ position }) => (
  <mesh position={position}>
    <sphereGeometry args={[0.2, 32, 32]} /> {/* Increased size and detail of spheres */}
    <meshStandardMaterial color="lightblue" />
  </mesh>
);

const LatticeVector = ({ start, end, color }) => {
  const points = [new THREE.Vector3(...start), new THREE.Vector3(...end)];
  const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
  return (
    <line geometry={lineGeometry}>
      <lineBasicMaterial color={color} linewidth={5} />
    </line>
  );
};

const VectorControls = ({ basis, setBasis }) => (
  <div style={{ padding: '10px', display: 'flex', flexDirection: 'column', alignItems: 'flex-start' }}>
    {Object.keys(basis).map((key) => (
      <label key={key} style={{ marginBottom: '5px' }}>
        {key.toUpperCase()}: <input type="number" value={basis[key]} onChange={(e) => setBasis({...basis, [key]: Number(e.target.value)})} style={{ marginLeft: '10px' }} />
      </label>
    ))}
  </div>
);

const LatticeDescription = () => (
  <div style={{ margin: '10px', maxWidth: '500px' }}>
    <h3>What is a Lattice?</h3>
    <p>
      Mathematically, a lattice in R^n is a set of points generated by linear combinations, with integer coefficients, of basis vectors in R^n . It can be visualized as a grid of points spaced according to these basis vectors. Lattices are fundamental in various areas, including cryptography, number theory, and crystallography.
    </p>
    <p>
      In cryptography, lattices are used to construct problems believed to be hard to solve, which are the basis for lattice-based cryptographic systems. These problems, such as the Shortest Vector Problem (SVP) or the Closest Vector Problem (CVP), provide security guarantees against both classical and quantum computers.
    </p>
  </div>
);

// Definition of LatticeProperties component
const LatticeProperties = ({ properties }) => (
  <div style={{ margin: '10px', padding: '10px', backgroundColor: '#f0f0f0' }}>
    <h3>Vector Properties:</h3>
    <p><strong>Orthogonality (Dot Products):</strong></p>
    <ul>
      <li>Vector 1 & Vector 2: {properties.orthogonality12.toFixed(2)}</li>
      <li>Vector 1 & Vector 3: {properties.orthogonality13.toFixed(2)}</li>
      <li>Vector 2 & Vector 3: {properties.orthogonality23.toFixed(2)}</li>
    </ul>
    <p><strong>Lengths:</strong></p>
    <ul>
      <li>Vector 1: {properties.length1.toFixed(2)} units</li>
      <li>Vector 2: {properties.length2.toFixed(2)} units</li>
      <li>Vector 3: {properties.length3.toFixed(2)} units</li>
    </ul>
  </div>
);


const LatticeAnimation = () => {
  const [basis, setBasis] = useState({ x1: 1, y1: 0, z1: 0, x2: 0, y2: 1, z2: 0, x3: 0, y3: 0, z3: 1 });
  const [properties, setProperties] = useState({ orthogonality12: 0, orthogonality13: 0, orthogonality23: 0, length1: 0, length2: 0, length3: 0 });

  useEffect(() => {
    const v1 = new THREE.Vector3(basis.x1, basis.y1, basis.z1);
    const v2 = new THREE.Vector3(basis.x2, basis.y2, basis.z2);
    const v3 = new THREE.Vector3(basis.x3, basis.y3, basis.z3);

    setProperties({
      orthogonality12: v1.dot(v2),
      orthogonality13: v1.dot(v3),
      orthogonality23: v2.dot(v3),
      length1: v1.length(),
      length2: v2.length(),
      length3: v3.length(),
    });
  }, [basis]);

  const points = [];
  for (let i = -5; i <= 5; i++) {  // Increased range for a more expansive lattice
    for (let j = -5; j <=
      5; j++) {
        for (let k = -5; k <= 5; k++) {
        points.push([
        i * basis.x1 + j * basis.x2 + k * basis.x3,
        i * basis.y1 + j * basis.y2 + k * basis.y3,
        i * basis.z1 + j * basis.z2 + k * basis.z3
        ]);
        }
        }
        }
        
        return (
          <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
            <Canvas camera={{ position: [10, 10, 10], fov: 60 }} style={{ height: '70vh', width: '70vw' }}>
              <ambientLight intensity={0.5} />
              <pointLight position={[20, 20, 20]} />
              {points.map((point, index) => (
                <LatticePoint key={index} position={point} />
              ))}
              <LatticeVector start={[0, 0, 0]} end={[basis.x1, basis.y1, basis.z1]} color="red" />
              <LatticeVector start={[0, 0, 0]} end={[basis.x2, basis.y2, basis.z2]} color="green" />
              <LatticeVector start={[0, 0, 0]} end={[basis.x3, basis.y3, basis.z3]} color="blue" />
              <OrbitControls />
            </Canvas>
            <div style={{ maxWidth: '30vw', marginLeft: '20px' }}>
              <VectorControls basis={basis} setBasis={setBasis} />
              <LatticeProperties properties={properties} />
              <LatticeDescription />
            </div>
          </div>
        );
        };
        
        export default LatticeAnimation;